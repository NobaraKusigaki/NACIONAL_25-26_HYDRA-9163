"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NetworkTablesTopic = void 0;
var tslib_1 = require("tslib");
var base_topic_1 = require("./base-topic");
var NetworkTablesTopic = /** @class */ (function (_super) {
    tslib_1.__extends(NetworkTablesTopic, _super);
    /**
     * Creates a new topic. This should only be done after the
     * base NTCore client has been initialized.
     * @param client - The client that owns the topic.
     * @param name - The name of the topic.
     * @param typeInfo - The type info for the topic.
     * @param defaultValue - The default value for the topic.
     */
    function NetworkTablesTopic(client, name, typeInfo, defaultValue) {
        var _this = _super.call(this, client, name) || this;
        _this.type = 'regular';
        _this._typeInfo = typeInfo;
        _this.value = defaultValue !== null && defaultValue !== void 0 ? defaultValue : null;
        _this._publisher = false;
        var existingTopic = _this.client.getTopicFromName(name);
        if (existingTopic) {
            if (existingTopic.typeInfo[0] === typeInfo[0] && existingTopic.typeInfo[1] === typeInfo[1]) {
                return existingTopic;
            }
            else {
                throw new Error("Topic ".concat(name, " already exists, but with a different type."));
            }
        }
        _this.client.registerTopic(_this);
        return _this;
    }
    Object.defineProperty(NetworkTablesTopic.prototype, "typeInfo", {
        /**
         * Gets the type info for the topic.
         * @returns The type info for the topic.
         */
        get: function () {
            return this._typeInfo;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(NetworkTablesTopic.prototype, "publisher", {
        /**
         * Gets whether the client is the publisher of the topic.
         * @returns Whether the client is the publisher of the topic.
         */
        get: function () {
            return this._publisher;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(NetworkTablesTopic.prototype, "pubuid", {
        /**
         * Gets the UID of the publisher.
         * @returns The UID of the publisher, or undefined if the client is not the publisher.
         */
        get: function () {
            return this._pubuid;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Sets the value of the topic.
     * The client must be the publisher of the topic to set the value.
     * @param value - The value to set.
     */
    NetworkTablesTopic.prototype.setValue = function (value) {
        if (!this.publisher) {
            throw new Error('Cannot set value on topic without being the publisher');
        }
        this.value = value;
        this.notifySubscribers();
        this.client.updateServer(this, value);
    };
    /**
     * Gets the value of the topic.
     * @returns The value of the topic.
     */
    NetworkTablesTopic.prototype.getValue = function () {
        return this.value;
    };
    /**
     * Updates the value of the topic.
     * This should only be called by the PubSubClient.
     * @param value - The value to update.
     * @param lastChangedTime - The server time of the last value change.
     */
    NetworkTablesTopic.prototype.updateValue = function (value, lastChangedTime) {
        this.value = value;
        this._lastChangedTime = lastChangedTime;
        this.notifySubscribers();
    };
    /** */
    /* ANNOUNCEMENTS */
    /** */
    /**
     * Marks the topic as announced. This should only be called by the PubSubClient.
     * @param params - The parameters of the announcement.
     */
    NetworkTablesTopic.prototype.announce = function (params) {
        _super.prototype.announce.call(this, params);
        if (params.pubuid === this._pubuid) {
            this._publisher = true;
        }
    };
    /** */
    /* SUBSCRIBING */
    /** */
    /**
     * Creates a new subscriber.
     * @param callback - The callback to call when the topic value changes.
     * @param options - The options for the subscriber.
     * @param id - The UID of the subscriber. You must verify that the ID is not already in use.
     * @param save - Whether to save the subscriber.
     * @returns The UID of the subscriber.
     */
    NetworkTablesTopic.prototype.subscribe = function (callback, options, id, save) {
        if (options === void 0) { options = {}; }
        if (save === void 0) { save = true; }
        var subuid = id || this.client.messenger.getNextSubUID();
        var subscribeParams = {
            topics: [this.name],
            subuid: subuid,
            options: options,
        };
        this.client.messenger.subscribe(subscribeParams);
        if (save)
            this.subscribers.set(subuid, { callback: callback, options: options });
        return subuid;
    };
    NetworkTablesTopic.prototype.resubscribeAll = function (client) {
        var _this = this;
        this.client = client;
        this.subscribers.forEach(function (info, subuid) {
            _this.subscribe(info.callback, info.options, subuid, false);
        });
    };
    /**
     * Notifies all subscribers of the current value.
     */
    NetworkTablesTopic.prototype.notifySubscribers = function () {
        var _this = this;
        // We know that _announceParams is not null here because we received a value update
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this.subscribers.forEach(function (info) { return info.callback(_this.value, _this._announceParams); });
    };
    /** */
    /* PUBLISHING */
    /** */
    /**
     * Publishes the topic.
     * @param properties - The properties to publish the topic with.
     * @param id - The UID of the publisher. You must verify that the ID is not already in use.
     * @returns A promise that resolves when the topic is published.
     */
    NetworkTablesTopic.prototype.publish = function () {
        return tslib_1.__awaiter(this, arguments, void 0, function (properties, id) {
            var publishParams;
            if (properties === void 0) { properties = {}; }
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.publisher)
                            return [2 /*return*/];
                        this._pubuid = id !== null && id !== void 0 ? id : this.client.messenger.getNextPubUID();
                        this._publishProperties = properties;
                        publishParams = {
                            type: this.typeInfo[1],
                            name: this.name,
                            pubuid: this._pubuid,
                            properties: properties,
                        };
                        return [4 /*yield*/, this.client.messenger.publish(publishParams)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Unpublishes the topic.
     */
    NetworkTablesTopic.prototype.unpublish = function () {
        if (!this.publisher || this._pubuid == null) {
            throw new Error('Cannot unpublish topic without being the publisher');
        }
        this.client.messenger.unpublish(this._pubuid);
        this._publisher = false;
        this._pubuid = undefined;
    };
    /**
     * Republishes the topic.
     * @param client - The client to republish with.
     * @returns A promise that resolves when the topic is republished.
     */
    NetworkTablesTopic.prototype.republish = function (client) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.client = client;
                        if (!this.publisher || this._pubuid == null) {
                            throw new Error('Cannot republish topic without being the publisher');
                        }
                        this._publisher = false;
                        return [4 /*yield*/, this.publish(this._publishProperties, this._pubuid)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    return NetworkTablesTopic;
}(base_topic_1.NetworkTablesBaseTopic));
exports.NetworkTablesTopic = NetworkTablesTopic;
//# sourceMappingURL=topic.js.map